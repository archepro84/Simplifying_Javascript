# Chapter 5 반복문을 단순하게 만들어라

## Tip 20 화살표 함수로 반복문을 단순하게 만들어라

### 화살표 함수 (Arrow function)

- 함수가 장황해지는 문제를 해결해서 함수 작성을 간결하고 짧게 만들어준다.
- function Keyword, 인수를 감싸는 괄호, return 키워드, 중괄호 없이 함수를 사용할 수 있게 한다.
- 매개 변수가 하나뿐이라면 괄호를 제거하여 함수를 작성할 수 있다.
- 변수에 할당하지 않고 익명 함수로 사용할 수도 있다.

## Tip 21 배열 메서드로 반복문을 짧게 작성하라

### for 문과 for...of 문

- 불필요할 정도로 어수선하게 작성된 코드일 수 있으므로 최대한 적게 사용하는 것이 좋다.
- 간결함, 가독성, 예측 가능성과 같은 목표에 부합하지는 않는다.

### 배열 메서드

- 불필요한 데이터를 배제한, 간결하고 예측 가능한 코드를 만드는 훌륭한 방법
- 배열의 길이를 변경하거나 배열 내 데이터 형태를 변경하는 등 한 가지 기능만 한다.
- ex) `reduce()`

### 배열 메서드 예시

```jsx
const team = [
    {
        name: 'melinda',
        position: 'ux designer'
    },
    {
        name: 'katie',
        position: 'strategist'
    },
    {
        name: 'madhavi',
        position: 'developer'
    },
    {
        name: 'justin',
        position: 'manager'
    },
    {
        name: 'chris',
        position: 'developer'
    }
]
```

### map()

- 동작: 형태를 바꿀 수 있지만 길이는 유지된다.
- 예시: 전체 팀원의 이름을 가져온다.
- 결과: [’melinda’, ‘datie’, ‘madhavi’, ‘justin’, ‘chris’]

### sort()

- 동작: 형태나 길이는 변경되지 않고 순서만 바꾼다.
- 예시: 팀원 이름을 알파벳순으로 정렬한다.
- 결과: [{name:’chris’, position: ‘developer’}, {name: ‘justin’ ...}]

### filter()

- 동작: 길이를 변경하지만 형태는 바꾸지 않는다.
- 예시: 개발자만 선택한다.
- 결과: [{name: ‘madhavi’, position: ‘developer’}, {name:’chris’, position:’developer’}]

### find()

- 동작: 배열을 반환하지 않습니다. 한 개의 데이터가 반환되고 형태는 바뀌지 않는다.
- 예시: 팀의 관리자를 찾습니다.
- 결과: {name: ‘justin’, position: ‘manager’}

### forEach()

- 동작: 형태를 이용하지만 아무것도 반환하지 않습니다.
- 예시: 모든 팀원에게 상여를 지급합니다.
- 결과: Melinda가 상여를 받았습니다! Katie가 상여를 받았습니다! ... (그렇지만 반환값은 없습니다.)

### reduce()

- 동작: 길이와 형태를 바꾸는 것을 비롯해 무엇이든 처리할 수 있습니다.
- 예시: 개발자와 개발자가 아닌 모든 팀원의 수를 계산합니다.
- 결과: {developers: 2, non-developers: 3}

## Tip 22 map() 메서드로 비슷한 길이의 배열을 생성하라

### map() 메서드

- 흔히 사용되고, 새롭게 생성되는 배열에 메서드의 콜백에서 반환하는 정보가 담긴다.
- 다른 배열 메서드에 비해 반환값을 알기 쉽다.
- 새로운 값을 담을 배열을 준비할 필요없이 사용할 수 있다.
- 원본 배열의 각 항목을 인수로 받아 새롭게 작성될 배열에 담길 값을 반환하는 함수를 만드는 것

### map 함수

- 입력한 배열의 정보 중 한 조각을 받아 새로운 값을 반환하거나 때로는 정보의 일부를 반환한다.
- 정보를 변형해서 새로운 값을 반환하기도 한다.
- 배열에 있는 한 가지 속성을 반환하거나 배열에 있는 값을 가져와서 다른 형식의 값을 반환한다.
- ex) 모든 값을 대문자로 변환, 정수를 화폐 단위로 변환해 새로운 배열을 반환

### 배열 메서드

- 배열 메서드에서는 익명 함수를 작성하거나 기명 함수를 사용할 수 있다.
- 모든 배열 메서드는 배열의 각 항목을 대상으로 실행할 콜백 함수를 받을 뿐이다.
- 배열 메서드의 종류에 따라 콜백 함수의 반환값이 처리되는 방법이 결정된다.

## Tip 23 filter()와 find()로 데이터의 부분집합을 생성하라.

### filter() 메서드

- 데이터의 형태는 유지하면서 전체 항목의 일부만 필요할 경우 사용한다.
- ex) 특정 도시에 사는 사용자만 가져오면서 해당 사용자의 정보까지 모두 필요한 경우
- filter() 메서드에 전달하는 함수는 반드시 참 값을 반환해야 한다.
- 배열의 각 항목을 순회할 때 참 값일 경우 값은 유지되지만, 참 값을 반환하지 않을 때는 새로운 배열에 값이 담기지 않는다.
- 반환되는 배열은 원본의 배열 순서를 그대로 유지한다.
- 항상 배열을 반환하며 조건에 일치하는 값이 없는 경우에도 **배열**을 반환한다.

### find() 메서드

- 찾으려는 항목이 하나인 것을 알고 있는 경우 사용한다.
- ex) 정렬된 배열에 담긴 특정 사용자가 페이지의 마지막 갱신 내용을 가져오는 경우
- 배열의 항목에 전달한 함수로 평가해 참 값을 반환하는 첫 번째 항목만 반환한다.
- 참 값이 존재하지 않다면 undefined를 반환한다.
- 반복문에서 break 문을 사용할 때 find() 메서드가 가장 적합하다.
- 조건에 맞는 항목이 없을 때, **undefined**가 반환된다.

## Tip 24 forEach()로 동일한 동작을 적용하라

### forEach() 메서드

- 입력 배열을 변경하지 않고, 모든 항목에 동일한 동작을 수행한다.
- ex) 모든 회원에게 메시지를 보내는 스크립트에서 개별 회원 정보를 가져오는 경우
- 예측 가능하면서도 다른 배열 메서드와 같이 연결할 수 있기 때문에 유용하다.
- forEach()에서 처리하는 동작은 모두 함수 외부에 영향을 준다.
- 반드시 부수 효과가 필요한 경우에 가장 유용하다.
- 체이닝 과정에서 다른 배열 메서드와 결합할 수 있어 사용한다.
- 매번 변수에 배열 메서드의 결괏값을 저장할 필요 없이 동일한 배열에서 여러 작업을 처리할 수 있다.

### 부수 효과

- 함수의 유효 범위 밖에 있는 무언가를 변경하는 것

## Tip 25 체이닝으로 메서드를 연결하라

### 체이닝

- 값을 다시 할당하지 않고 반환된 객체(or 원래 객체)에 메서드를 즉시 호출하는 것
- 여러 개의 배열 메서드에서 배열이 반환될 때, 배열메서드를 연이어 호출할 수 있는 것
- 결괏값에 직접 메서드를 호출해 변수에 할당하는 중간 단계를 제거할 수 있다.

### 체이닝의 단점

- 새로운 메서드를 호출할 때마다 반환된 배열 전체를 다시 반복한다.
- 즉, 일반적인 for문 보다 반복 횟수가 좀 더 많아질 수 있다.

### 체이닝을 사용하기 전 확인해야할 점

1. 마지막 문장까지 세미콜론이 없는 것을 확인해야 한다.
2. 사용하는 메서드들의 순서를 지켜야한다.

## Tip 26 reduce()로 배열 데이터를 변환하라

### 배열 메서드의 장점

- 콜백 함수를 이해하기 전에도 결괏값을 한눈에 예측할 수 있다.

### reduce() 메서드

- 배열의 길이와 데이터 형태를 모두 또는 각각 변경할 수 있다.
- 반드시 배열을 반환할 필요가 없다.
- 콜백 함수에서 항상 누적된 값을 반환해야 한다.
- reducer가 더 많은 값을 쉽게 다룰수 있도록 코드에 **유연성**을 제공해 효율적인 코드를 작성할 수 있다.

## Tip 27 for...in 문과 for...of 문으로 반복문을 정리하라

### 배열 메서드의 단점

- 필요한 결과와 일치하지 않을 때, 반복문에서 빠져나올 수 없다.
- 배열이 아닌 컬렉션을 다룰 때 배열 메서드를 사용할 경우 로직이 복잡해질 수 있다.

### Map 이터레이터

- 항목을 한 번에 하나씩 접근할 수 있는 특정한 형식의 객체이다.
- Map, Array, Set에 존재한다.
- for ... of 문으로 이터레이터를 사용할 수 있다.
- for ... of 문은 색인 (let i = 0 부분)을 반복하지 않는다는 것을 제외하곤 for과 유사하다.
- for ... of 문은 색인 대신 컬렉션의 멤버를 직접 순회한다.

### for ... of문

- for 문에서 entries[i]로 컬렉션 전체를 참조하는 것을 벗어날 수 있다.
- 이터러블을 순회하기 위해 배열로 변환할 필요가 없어 최적화도 이루어진다.
- 반복문으로 무엇이든 할 수 있기 때문에 예측 가능성이 줄어드는 문제가있다.

### for ... in문

- 객체를 입력받을 때 각 항목을 한 번에 하나씩 받는다
- 매번 키를 사용해서 전체 컬렉션을 참조해야 한다.
- 선언한 변수의 값은 반복문이 진행되면서 계속 바뀐다.
- 키-값 쌍이 아니라 속성을 가져오기 때문에 이름과 값을 따로 추출할 필요가 없다.
- 값이 필요할 때마다 배열 표기법으로 개별 항목의 값을 가져올 수 있다.

### 객체를 순회하면서 객체를 조작하지 마라.

- 객체를 조작하는 것은 매우 위험하다.
- 특히 반복 중인 속성 외의 다른 속성을 추가하거나 수정하는 경우 버그가 빠르게 퍼질 수 있다.